# Go Testing Strategies with Claude-Flow

Comprehensive testing approaches for Go applications using claude-flow to automate test generation and execution.

## 🧪 Testing Framework Overview

### Go Testing Fundamentals
```bash
# Generate comprehensive test suite
npx claude-flow sparc tdd "user authentication service with comprehensive tests"

# Or generate specific test types
npx claude-flow sparc run tester "unit tests with table-driven tests and mocks"
```

## 📋 Test Types and Strategies

### 1. Unit Testing with Table-Driven Tests
```go
// internal/services/user_service_test.go - Generated by claude-flow
package services

import (
    "context"
    "errors"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/username/project/internal/models"
    "github.com/username/project/internal/repository/mocks"
)

func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name          string
        user          *models.User
        mockSetup     func(*mocks.UserRepository)
        expectedError string
        expectedUser  *models.User
    }{
        {
            name: "successful user creation",
            user: &models.User{
                Name:  "John Doe",
                Email: "john@example.com",
            },
            mockSetup: func(repo *mocks.UserRepository) {
                repo.On("Create", mock.Anything, mock.AnythingOfType("*models.User")).
                    Return(&models.User{
                        ID:    1,
                        Name:  "John Doe",
                        Email: "john@example.com",
                    }, nil)
            },
            expectedUser: &models.User{
                ID:    1,
                Name:  "John Doe",
                Email: "john@example.com",
            },
        },
        {
            name: "duplicate email error",
            user: &models.User{
                Name:  "Jane Doe",
                Email: "existing@example.com",
            },
            mockSetup: func(repo *mocks.UserRepository) {
                repo.On("Create", mock.Anything, mock.AnythingOfType("*models.User")).
                    Return(nil, errors.New("duplicate email"))
            },
            expectedError: "duplicate email",
        },
        {
            name: "invalid email format",
            user: &models.User{
                Name:  "Invalid User",
                Email: "invalid-email",
            },
            expectedError: "invalid email format",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup
            mockRepo := new(mocks.UserRepository)
            if tt.mockSetup != nil {
                tt.mockSetup(mockRepo)
            }

            service := NewUserService(mockRepo)
            ctx := context.Background()

            // Execute
            result, err := service.CreateUser(ctx, tt.user)

            // Assert
            if tt.expectedError != "" {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.expectedError)
                assert.Nil(t, result)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.expectedUser, result)
            }

            mockRepo.AssertExpectations(t)
        })
    }
}

// Subtests for complex scenarios
func TestUserService_GetUser(t *testing.T) {
    mockRepo := new(mocks.UserRepository)
    service := NewUserService(mockRepo)
    ctx := context.Background()

    t.Run("existing user", func(t *testing.T) {
        user := &models.User{ID: 1, Name: "John", Email: "john@example.com"}
        mockRepo.On("GetByID", ctx, 1).Return(user, nil).Once()

        result, err := service.GetUser(ctx, 1)

        assert.NoError(t, err)
        assert.Equal(t, user, result)
    })

    t.Run("non-existing user", func(t *testing.T) {
        mockRepo.On("GetByID", ctx, 999).Return(nil, errors.New("user not found")).Once()

        result, err := service.GetUser(ctx, 999)

        assert.Error(t, err)
        assert.Nil(t, result)
        assert.Contains(t, err.Error(), "user not found")
    })

    mockRepo.AssertExpectations(t)
}

// Benchmark tests
func BenchmarkUserService_CreateUser(b *testing.B) {
    mockRepo := new(mocks.UserRepository)
    service := NewUserService(mockRepo)
    ctx := context.Background()

    user := &models.User{
        Name:  "Benchmark User",
        Email: "benchmark@example.com",
    }

    mockRepo.On("Create", mock.Anything, mock.Anything).Return(user, nil)

    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        _, _ = service.CreateUser(ctx, user)
    }
}
```

### 2. Integration Testing
```go
// test/integration/user_integration_test.go - Generated by claude-flow
// +build integration

package integration

import (
    "context"
    "database/sql"
    "fmt"
    "os"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"

    "github.com/username/project/internal/database"
    "github.com/username/project/internal/repository"
    "github.com/username/project/internal/services"
)

type UserIntegrationTestSuite struct {
    suite.Suite
    db        *sql.DB
    container *postgres.PostgresContainer
    service   *services.UserService
}

func (suite *UserIntegrationTestSuite) SetupSuite() {
    ctx := context.Background()

    // Start PostgreSQL container
    container, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:15"),
        postgres.WithDatabase("testdb"),
        postgres.WithUsername("testuser"),
        postgres.WithPassword("testpass"),
    )
    suite.Require().NoError(err)

    suite.container = container

    // Get connection string
    connStr, err := container.ConnectionString(ctx, "sslmode=disable")
    suite.Require().NoError(err)

    // Connect to database
    db, err := sql.Open("postgres", connStr)
    suite.Require().NoError(err)
    suite.db = db

    // Run migrations
    err = database.Migrate(db)
    suite.Require().NoError(err)

    // Setup service
    repo := repository.NewUserRepository(db)
    suite.service = services.NewUserService(repo)
}

func (suite *UserIntegrationTestSuite) TearDownSuite() {
    if suite.db != nil {
        suite.db.Close()
    }
    if suite.container != nil {
        suite.container.Terminate(context.Background())
    }
}

func (suite *UserIntegrationTestSuite) SetupTest() {
    // Clean database before each test
    _, err := suite.db.Exec("TRUNCATE TABLE users RESTART IDENTITY CASCADE")
    suite.Require().NoError(err)
}

func (suite *UserIntegrationTestSuite) TestCreateAndGetUser() {
    ctx := context.Background()

    // Create user
    user := &models.User{
        Name:  "Integration Test User",
        Email: "integration@example.com",
    }

    createdUser, err := suite.service.CreateUser(ctx, user)
    suite.Require().NoError(err)
    suite.Assert().NotZero(createdUser.ID)
    suite.Assert().Equal("Integration Test User", createdUser.Name)
    suite.Assert().Equal("integration@example.com", createdUser.Email)

    // Get user
    retrievedUser, err := suite.service.GetUser(ctx, createdUser.ID)
    suite.Require().NoError(err)
    suite.Assert().Equal(createdUser, retrievedUser)
}

func (suite *UserIntegrationTestSuite) TestUserLifecycle() {
    ctx := context.Background()

    // Create user
    user := &models.User{
        Name:  "Lifecycle User",
        Email: "lifecycle@example.com",
    }

    createdUser, err := suite.service.CreateUser(ctx, user)
    suite.Require().NoError(err)

    // Update user
    createdUser.Name = "Updated Lifecycle User"
    updatedUser, err := suite.service.UpdateUser(ctx, createdUser)
    suite.Require().NoError(err)
    suite.Assert().Equal("Updated Lifecycle User", updatedUser.Name)

    // List users
    users, err := suite.service.ListUsers(ctx, 10, 0)
    suite.Require().NoError(err)
    suite.Assert().Len(users, 1)

    // Delete user
    err = suite.service.DeleteUser(ctx, createdUser.ID)
    suite.Require().NoError(err)

    // Verify deletion
    _, err = suite.service.GetUser(ctx, createdUser.ID)
    suite.Assert().Error(err)
}

func TestUserIntegrationTestSuite(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration tests in short mode")
    }

    suite.Run(t, new(UserIntegrationTestSuite))
}
```

### 3. End-to-End Testing
```go
// test/e2e/api_test.go - Generated by claude-flow
// +build e2e

package e2e

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "net/http/httptest"
    "os"
    "testing"

    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"

    "github.com/username/project/cmd/server"
    "github.com/username/project/internal/config"
)

type E2ETestSuite struct {
    suite.Suite
    server *httptest.Server
    client *http.Client
}

func (suite *E2ETestSuite) SetupSuite() {
    // Setup test configuration
    os.Setenv("ENV", "test")
    os.Setenv("DATABASE_URL", "postgres://testuser:testpass@localhost/testdb?sslmode=disable")

    // Initialize application
    cfg := config.Load()
    gin.SetMode(gin.TestMode)

    router, err := server.SetupRouter(cfg)
    suite.Require().NoError(err)

    suite.server = httptest.NewServer(router)
    suite.client = &http.Client{}
}

func (suite *E2ETestSuite) TearDownSuite() {
    if suite.server != nil {
        suite.server.Close()
    }
}

func (suite *E2ETestSuite) TestUserWorkflow() {
    baseURL := suite.server.URL

    // Test user registration
    registerPayload := map[string]string{
        "name":     "E2E Test User",
        "email":    "e2e@example.com",
        "password": "testpassword",
    }

    registerResp := suite.makeRequest("POST", baseURL+"/api/v1/auth/register", registerPayload)
    suite.Assert().Equal(http.StatusCreated, registerResp.StatusCode)

    var registerResult map[string]interface{}
    suite.decodeResponse(registerResp, &registerResult)

    // Test user login
    loginPayload := map[string]string{
        "email":    "e2e@example.com",
        "password": "testpassword",
    }

    loginResp := suite.makeRequest("POST", baseURL+"/api/v1/auth/login", loginPayload)
    suite.Assert().Equal(http.StatusOK, loginResp.StatusCode)

    var loginResult map[string]interface{}
    suite.decodeResponse(loginResp, &loginResult)

    token := loginResult["token"].(string)
    suite.Assert().NotEmpty(token)

    // Test protected endpoint
    profileResp := suite.makeAuthenticatedRequest("GET", baseURL+"/api/v1/profile", nil, token)
    suite.Assert().Equal(http.StatusOK, profileResp.StatusCode)

    var profileResult map[string]interface{}
    suite.decodeResponse(profileResp, &profileResult)
    suite.Assert().Equal("E2E Test User", profileResult["name"])
    suite.Assert().Equal("e2e@example.com", profileResult["email"])
}

func (suite *E2ETestSuite) TestAPIErrorHandling() {
    baseURL := suite.server.URL

    // Test invalid login
    invalidLogin := map[string]string{
        "email":    "nonexistent@example.com",
        "password": "wrongpassword",
    }

    resp := suite.makeRequest("POST", baseURL+"/api/v1/auth/login", invalidLogin)
    suite.Assert().Equal(http.StatusUnauthorized, resp.StatusCode)

    // Test unauthorized access
    resp = suite.makeRequest("GET", baseURL+"/api/v1/profile", nil)
    suite.Assert().Equal(http.StatusUnauthorized, resp.StatusCode)

    // Test invalid data
    invalidUser := map[string]string{
        "name":  "",
        "email": "invalid-email",
    }

    resp = suite.makeRequest("POST", baseURL+"/api/v1/auth/register", invalidUser)
    suite.Assert().Equal(http.StatusBadRequest, resp.StatusCode)
}

func (suite *E2ETestSuite) makeRequest(method, url string, payload interface{}) *http.Response {
    var body bytes.Buffer
    if payload != nil {
        json.NewEncoder(&body).Encode(payload)
    }

    req, err := http.NewRequest(method, url, &body)
    suite.Require().NoError(err)

    if payload != nil {
        req.Header.Set("Content-Type", "application/json")
    }

    resp, err := suite.client.Do(req)
    suite.Require().NoError(err)

    return resp
}

func (suite *E2ETestSuite) makeAuthenticatedRequest(method, url string, payload interface{}, token string) *http.Response {
    resp := suite.makeRequest(method, url, payload)
    resp.Request.Header.Set("Authorization", "Bearer "+token)
    return resp
}

func (suite *E2ETestSuite) decodeResponse(resp *http.Response, target interface{}) {
    defer resp.Body.Close()
    err := json.NewDecoder(resp.Body).Decode(target)
    suite.Require().NoError(err)
}

func TestE2ETestSuite(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping E2E tests in short mode")
    }

    suite.Run(t, new(E2ETestSuite))
}
```

## 🎭 Mock Generation and Usage

### Automated Mock Generation
```bash
# Generate mocks with claude-flow
npx claude-flow sparc run coder "generate mocks for all interfaces using mockery"

# Or use Go generate
//go:generate mockery --name=UserRepository --output=mocks --outpkg=mocks
```

**Generated Mock Usage:**
```go
// internal/repository/mocks/user_repository.go - Generated by claude-flow
package mocks

import (
    "context"

    "github.com/stretchr/testify/mock"
    "github.com/username/project/internal/models"
)

type UserRepository struct {
    mock.Mock
}

func (m *UserRepository) Create(ctx context.Context, user *models.User) (*models.User, error) {
    args := m.Called(ctx, user)
    return args.Get(0).(*models.User), args.Error(1)
}

func (m *UserRepository) GetByID(ctx context.Context, id int) (*models.User, error) {
    args := m.Called(ctx, id)
    return args.Get(0).(*models.User), args.Error(1)
}

func (m *UserRepository) Update(ctx context.Context, user *models.User) (*models.User, error) {
    args := m.Called(ctx, user)
    return args.Get(0).(*models.User), args.Error(1)
}

func (m *UserRepository) Delete(ctx context.Context, id int) error {
    args := m.Called(ctx, id)
    return args.Error(0)
}

func (m *UserRepository) List(ctx context.Context, limit, offset int) ([]*models.User, error) {
    args := m.Called(ctx, limit, offset)
    return args.Get(0).([]*models.User), args.Error(1)
}
```

## ⚡ Performance and Load Testing

### Benchmark Tests
```go
// test/benchmark/user_service_bench_test.go - Generated by claude-flow
package benchmark

import (
    "context"
    "testing"

    "github.com/username/project/internal/models"
    "github.com/username/project/internal/services"
    "github.com/username/project/internal/repository/mocks"
)

func BenchmarkUserService_CreateUser(b *testing.B) {
    mockRepo := new(mocks.UserRepository)
    service := services.NewUserService(mockRepo)
    ctx := context.Background()

    user := &models.User{
        Name:  "Benchmark User",
        Email: "benchmark@example.com",
    }

    mockRepo.On("Create", ctx, user).Return(user, nil)

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, _ = service.CreateUser(ctx, user)
    }
}

func BenchmarkUserService_GetUser(b *testing.B) {
    mockRepo := new(mocks.UserRepository)
    service := services.NewUserService(mockRepo)
    ctx := context.Background()

    user := &models.User{
        ID:    1,
        Name:  "Benchmark User",
        Email: "benchmark@example.com",
    }

    mockRepo.On("GetByID", ctx, 1).Return(user, nil)

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, _ = service.GetUser(ctx, 1)
    }
}

// Parallel benchmarks
func BenchmarkUserService_CreateUser_Parallel(b *testing.B) {
    mockRepo := new(mocks.UserRepository)
    service := services.NewUserService(mockRepo)
    ctx := context.Background()

    user := &models.User{
        Name:  "Parallel Benchmark User",
        Email: "parallel@example.com",
    }

    mockRepo.On("Create", ctx, user).Return(user, nil)

    b.ResetTimer()
    b.ReportAllocs()

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            _, _ = service.CreateUser(ctx, user)
        }
    })
}

// Memory allocation benchmarks
func BenchmarkMemoryAllocation(b *testing.B) {
    b.Run("UserCreation", func(b *testing.B) {
        b.ReportAllocs()
        for i := 0; i < b.N; i++ {
            user := &models.User{
                Name:  "Memory Test User",
                Email: "memory@example.com",
            }
            _ = user
        }
    })

    b.Run("UserSliceCreation", func(b *testing.B) {
        b.ReportAllocs()
        for i := 0; i < b.N; i++ {
            users := make([]*models.User, 100)
            _ = users
        }
    })
}
```

### Load Testing with CLI
```bash
# Generate load test with claude-flow
npx claude-flow sparc run tester "create load test for user API endpoints"

# Run benchmarks
go test -bench=. -benchmem -cpuprofile=cpu.prof -memprofile=mem.prof ./test/benchmark/

# Analyze profiles
go tool pprof cpu.prof
go tool pprof mem.prof
```

## 🔬 Test Coverage and Quality

### Coverage Configuration
```bash
# Generate test coverage with claude-flow
npx claude-flow sparc run tester "setup comprehensive test coverage reporting"
```

**Generated Coverage Script:**
```bash
#!/bin/bash
# scripts/test-coverage.sh - Generated by claude-flow

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Running Go tests with coverage...${NC}"

# Create coverage directory
mkdir -p coverage

# Run tests with coverage
go test -v -race -coverprofile=coverage/coverage.out ./...

# Check if coverage file was created
if [ ! -f coverage/coverage.out ]; then
    echo -e "${RED}Error: Coverage file not created${NC}"
    exit 1
fi

# Generate HTML coverage report
go tool cover -html=coverage/coverage.out -o coverage/coverage.html

# Calculate coverage percentage
COVERAGE=$(go tool cover -func=coverage/coverage.out | grep total | awk '{print $3}' | sed 's/%//')

echo -e "${GREEN}Coverage report generated: coverage/coverage.html${NC}"
echo -e "${GREEN}Total coverage: ${COVERAGE}%${NC}"

# Set minimum coverage threshold
THRESHOLD=80

if (( $(echo "$COVERAGE >= $THRESHOLD" | bc -l) )); then
    echo -e "${GREEN}✓ Coverage threshold met (${COVERAGE}% >= ${THRESHOLD}%)${NC}"
    exit 0
else
    echo -e "${RED}✗ Coverage below threshold (${COVERAGE}% < ${THRESHOLD}%)${NC}"
    exit 1
fi
```

### Test Quality Metrics
```go
// internal/testing/quality.go - Generated by claude-flow
package testing

import (
    "go/ast"
    "go/parser"
    "go/token"
    "path/filepath"
    "strings"
)

type TestQualityMetrics struct {
    TotalTests       int
    TestsWithMocks   int
    TableDrivenTests int
    BenchmarkTests   int
    Coverage         float64
}

func AnalyzeTestQuality(dir string) (*TestQualityMetrics, error) {
    metrics := &TestQualityMetrics{}

    err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        if !strings.HasSuffix(path, "_test.go") {
            return nil
        }

        return analyzeTestFile(path, metrics)
    })

    return metrics, err
}

func analyzeTestFile(filename string, metrics *TestQualityMetrics) error {
    fset := token.NewFileSet()
    node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
    if err != nil {
        return err
    }

    ast.Inspect(node, func(n ast.Node) bool {
        switch x := n.(type) {
        case *ast.FuncDecl:
            if x.Name.IsExported() && strings.HasPrefix(x.Name.Name, "Test") {
                metrics.TotalTests++

                // Check for table-driven tests
                if hasTableDrivenPattern(x) {
                    metrics.TableDrivenTests++
                }

                // Check for mocks
                if usesMocks(x) {
                    metrics.TestsWithMocks++
                }
            } else if strings.HasPrefix(x.Name.Name, "Benchmark") {
                metrics.BenchmarkTests++
            }
        }
        return true
    })

    return nil
}

func hasTableDrivenPattern(fn *ast.FuncDecl) bool {
    // Look for patterns like "tests := []struct{"
    // This is a simplified check
    for _, stmt := range fn.Body.List {
        if assign, ok := stmt.(*ast.AssignStmt); ok {
            for _, lhs := range assign.Lhs {
                if ident, ok := lhs.(*ast.Ident); ok && ident.Name == "tests" {
                    return true
                }
            }
        }
    }
    return false
}

func usesMocks(fn *ast.FuncDecl) bool {
    // Look for mock usage patterns
    ast.Inspect(fn, func(n ast.Node) bool {
        if call, ok := n.(*ast.CallExpr); ok {
            if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
                if sel.Sel.Name == "On" || sel.Sel.Name == "AssertExpectations" {
                    return true
                }
            }
        }
        return true
    })
    return false
}
```

## 🚀 Test-Driven Development with Claude-Flow

### TDD Workflow
```bash
# Complete TDD cycle with claude-flow
npx claude-flow sparc tdd "user authentication service"

# This generates:
# 1. Failing tests first
# 2. Minimal implementation
# 3. Refactoring suggestions
# 4. Additional test cases
```

### Continuous Testing
```yaml
# .github/workflows/test.yml - Generated by claude-flow
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

    - name: Install dependencies
      run: go mod download

    - name: Run unit tests
      run: go test -v -race -coverprofile=coverage.out ./...

    - name: Run integration tests
      run: go test -v -tags=integration ./test/integration/
      env:
        DATABASE_URL: postgres://testuser:testpass@localhost/testdb?sslmode=disable

    - name: Run benchmarks
      run: go test -bench=. -benchmem ./test/benchmark/

    - name: Upload coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out

    - name: Generate coverage report
      run: go tool cover -html=coverage.out -o coverage.html

    - name: Upload coverage report
      uses: actions/upload-artifact@v3
      with:
        name: coverage-report
        path: coverage.html
```

## 🛠️ Testing Tools and Utilities

### Test Helpers
```go
// internal/testing/helpers.go - Generated by claude-flow
package testing

import (
    "database/sql"
    "testing"

    "github.com/stretchr/testify/require"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
)

type TestDatabase struct {
    Container *postgres.PostgresContainer
    DB        *sql.DB
}

func SetupTestDatabase(t *testing.T) *TestDatabase {
    ctx := context.Background()

    container, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:15"),
        postgres.WithDatabase("testdb"),
        postgres.WithUsername("testuser"),
        postgres.WithPassword("testpass"),
    )
    require.NoError(t, err)

    connStr, err := container.ConnectionString(ctx, "sslmode=disable")
    require.NoError(t, err)

    db, err := sql.Open("postgres", connStr)
    require.NoError(t, err)

    return &TestDatabase{
        Container: container,
        DB:        db,
    }
}

func (td *TestDatabase) Cleanup(t *testing.T) {
    if td.DB != nil {
        td.DB.Close()
    }
    if td.Container != nil {
        td.Container.Terminate(context.Background())
    }
}

// Test fixtures
func CreateTestUser(t *testing.T) *models.User {
    return &models.User{
        Name:  "Test User",
        Email: "test@example.com",
    }
}

func CreateTestUsers(t *testing.T, count int) []*models.User {
    users := make([]*models.User, count)
    for i := 0; i < count; i++ {
        users[i] = &models.User{
            Name:  fmt.Sprintf("Test User %d", i+1),
            Email: fmt.Sprintf("test%d@example.com", i+1),
        }
    }
    return users
}

// Assertion helpers
func AssertUserEqual(t *testing.T, expected, actual *models.User) {
    require.Equal(t, expected.Name, actual.Name)
    require.Equal(t, expected.Email, actual.Email)
    if expected.ID != 0 {
        require.Equal(t, expected.ID, actual.ID)
    }
}
```

## 🚀 Claude-Flow Testing Commands

```bash
# Generate complete test suite
npx claude-flow sparc tdd "complete user management system"

# Generate specific test types
npx claude-flow sparc run tester "integration tests with testcontainers"
npx claude-flow sparc run tester "benchmark tests for API endpoints"
npx claude-flow sparc run tester "property-based tests with fuzzing"

# Test analysis and improvement
npx claude-flow sparc run reviewer "analyze test coverage and suggest improvements"
npx claude-flow sparc run tester "add missing test cases for edge scenarios"

# Performance testing
npx claude-flow sparc run perf-analyzer "create load tests for concurrent operations"
```

## 📈 Best Practices

### 1. Test Organization
- **Arrange-Act-Assert**: Clear test structure
- **Table-Driven Tests**: Test multiple scenarios efficiently
- **Test Suites**: Group related tests using testify/suite
- **Parallel Tests**: Use t.Parallel() for independent tests

### 2. Mock Strategy
- **Interface-Based Mocking**: Mock at interface boundaries
- **Minimal Mocking**: Only mock what you need
- **Mock Verification**: Always verify mock expectations
- **Dependency Injection**: Design for testability

### 3. Coverage Goals
- **80%+ Coverage**: Aim for high coverage
- **Quality over Quantity**: Focus on meaningful tests
- **Edge Cases**: Test error conditions and boundaries
- **Integration Points**: Test service interactions

**Next Steps:**
- [Performance](../performance/) - Optimize and profile Go applications
- [Microservices](../microservices/) - Build distributed systems
- [Examples](../examples/) - See complete testing implementations