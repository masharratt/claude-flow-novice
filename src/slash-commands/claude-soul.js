#!/usr/bin/env node

/**
 * CLAUDE-SOUL.md Slash Command
 *
 * Interactive questionnaire to create a project soul document.
 * Guides users through defining their project's who, what, when, where, why
 * to provide context for AI agents when they hit roadblocks.
 * Document size: 250-500 words focusing on project essence and decision context.
 */

import fs from 'fs/promises';
import path from 'path';
import readline from 'readline';

export class ClaudeSoulSlashCommand {
  constructor(projectPath = process.cwd()) {
    this.projectPath = projectPath;
    this.claudeSoulPath = path.join(projectPath, 'claude-soul.md');
    this.rl = null;
  }

  /**
   * Main slash command execution
   */
  async execute(options = {}) {
    const {
      backup = true,
      preview = false,
      force = false,
      interactive = true
    } = options;

    try {
      console.log('🚀 Creating your project soul document...');

      if (!preview) {
        console.log('📝 This interactive questionnaire will help AI agents understand your project context.');
        console.log('');
      }

      let projectData;

      if (interactive && !preview) {
        // Step 1: Run interactive questionnaire
        projectData = await this.runQuestionnaire();

        if (!projectData) {
          return {
            success: false,
            action: 'cancelled',
            message: 'Questionnaire cancelled by user'
          };
        }
      } else {
        // Fallback to auto-generation for preview mode
        projectData = await this.autoGenerateData();
      }

      // Step 2: Generate soul content
      const soulContent = await this.generateSoulContent(projectData);

      // Step 3: Handle preview mode
      if (preview) {
        return {
          success: true,
          action: 'preview',
          content: soulContent,
          message: 'Preview generated successfully'
        };
      }

      // Step 4: Check for existing file
      const existingSoulExists = await this.fileExists(this.claudeSoulPath);

      // Step 5: Handle force/confirmation for existing files
      if (existingSoulExists && !force) {
        const shouldOverwrite = await this.confirmOverwrite();
        if (!shouldOverwrite) {
          return {
            success: false,
            action: 'cancelled',
            message: 'Generation cancelled by user'
          };
        }
      }

      // Step 6: Create backup if requested
      if (backup && existingSoulExists) {
        await this.createBackup();
      }

      // Step 7: Write the file
      await fs.writeFile(this.claudeSoulPath, soulContent, 'utf8');

      console.log('');
      console.log('✅ claude-soul.md created successfully!');
      console.log('📊 AI agents can now reference this document for project context.');

      return {
        success: true,
        action: 'generated',
        file: 'claude-soul.md',
        length: soulContent.length,
        lineCount: soulContent.split('\n').length
      };

    } catch (error) {
      console.error('❌ claude-soul.md generation failed:', error.message);
      return {
        success: false,
        action: 'error',
        error: error.message
      };
    } finally {
      if (this.rl) {
        this.rl.close();
      }
    }
  }

  /**
   * Generate the soul content from questionnaire data
   */
  async generateSoulContent(projectData) {
    const projectName = projectData.name || path.basename(this.projectPath);

    return `# ${projectName} - Project Soul

> **AI Context**: This document provides essential project context to help AI agents understand goals, make decisions, and maintain alignment with project values when encountering roadblocks or architectural choices.

## WHO - The People

**Project Owner**: ${projectData.owner || 'Not specified'}
**Target Users**: ${projectData.targetUsers || 'Not specified'}
**Team**: ${projectData.teamSize || 'Not specified'}

## WHAT - The Project

**Purpose**: ${projectData.purpose}

**Core Problem**: ${projectData.problem}

**Key Features**:
${(projectData.features || []).map(feature => `- ${feature}`).join('\n') || '- Not specified'}

**Success Metrics**: ${projectData.successMetrics || 'Not specified'}

## WHEN - The Timeline

**Project Stage**: ${projectData.stage || 'Not specified'}
**Key Milestones**: ${projectData.milestones || 'Not specified'}
**Constraints**: ${projectData.timeConstraints || 'None specified'}

## WHERE - The Context

**Domain**: ${projectData.domain || 'General software'}
**Environment**: ${projectData.environment || 'Not specified'}
**Scale**: ${projectData.scale || 'Small to medium'}

## WHY - The Motivation

**Vision**: ${projectData.vision}

**Values**:
${(projectData.values || []).map(value => `- ${value}`).join('\n') || '- Quality and maintainability'}

**Impact**: ${projectData.impact || 'Positive user experience'}

## TECHNICAL SOUL

**Architecture Preference**: ${projectData.architecture || 'Clean and maintainable'}
**Technology Stack**: ${projectData.techStack || 'Modern best practices'}
**Quality Standards**: ${projectData.quality || 'High standards with testing'}
**Decision Framework**: ${projectData.decisions || 'Pragmatic choices balancing speed and quality'}

---

> **AI Assistant Guidance**: When you encounter ambiguity or need to make technical decisions, refer to this document. Prioritize solutions that align with the stated values, target users, and technical preferences. If unsure, ask for clarification within the context of these project goals.

*Created: ${new Date().toLocaleDateString()} | Words: ${this.countWords(projectData)} | Purpose: AI Decision Context*
`;
  }

  /**
   * Run interactive questionnaire to gather project data
   */
  async runQuestionnaire() {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    console.log('📋 Let\'s define your project\'s soul! (Press Ctrl+C anytime to cancel)');
    console.log('💡 This context helps AI agents make better decisions when they encounter roadblocks.');
    console.log('');

    try {
      const projectData = {};

      // WHO questions
      console.log('\n🙋 WHO - The People Behind This Project');
      projectData.owner = await this.ask('Who is the main owner/maintainer of this project?', 'Individual developer');
      projectData.targetUsers = await this.ask('Who are your primary users/audience?', 'Developers');
      projectData.teamSize = await this.ask('Team size (solo, 2-5, 6-20, 20+)?', 'Solo');

      // WHAT questions
      console.log('\n📦 WHAT - The Project Essence');
      projectData.name = await this.ask('Project name?', path.basename(this.projectPath));
      projectData.purpose = await this.ask('What does this project do? (1-2 sentences)', 'Solves development problems');
      projectData.problem = await this.ask('What specific problem does it solve?', 'Streamlines common tasks');

      const featuresInput = await this.ask('Key features (comma-separated)?', 'Core functionality');
      projectData.features = featuresInput.split(',').map(f => f.trim()).filter(f => f);

      projectData.successMetrics = await this.ask('How do you measure success?', 'User satisfaction and adoption');

      // WHEN questions
      console.log('\n⏰ WHEN - Timeline and Stage');
      projectData.stage = await this.ask('Current stage (concept/prototype/mvp/production/mature)?', 'Development');
      projectData.milestones = await this.ask('Key upcoming milestones?', 'Feature completion');
      projectData.timeConstraints = await this.ask('Any time constraints or deadlines?', 'None');

      // WHERE questions
      console.log('\n🌍 WHERE - Context and Environment');
      projectData.domain = await this.ask('What domain/industry?', 'Software development');
      projectData.environment = await this.ask('Deployment environment (local/web/mobile/enterprise)?', 'Web');
      projectData.scale = await this.ask('Expected scale (personal/small team/enterprise)?', 'Small team');

      // WHY questions
      console.log('\n💡 WHY - Motivation and Vision');
      projectData.vision = await this.ask('What\'s your long-term vision?', 'Create valuable, maintainable software');

      const valuesInput = await this.ask('Core values (comma-separated)?', 'Quality, simplicity, maintainability');
      projectData.values = valuesInput.split(',').map(v => v.trim()).filter(v => v);

      projectData.impact = await this.ask('What impact do you want to achieve?', 'Improve developer productivity');

      // TECHNICAL questions
      console.log('\n⚙️ TECHNICAL - Architecture and Approach');
      projectData.architecture = await this.ask('Preferred architecture style?', 'Clean and modular');
      projectData.techStack = await this.ask('Technology preferences?', 'Modern, well-supported tools');
      projectData.quality = await this.ask('Quality standards?', 'High with automated testing');
      projectData.decisions = await this.ask('How should AI agents make decisions when unclear?', 'Ask for clarification, prefer maintainable solutions');

      console.log('');
      console.log('✅ Questionnaire complete! Generating your project soul document...');

      return projectData;
    } catch (error) {
      if (error.message === 'CANCELLED') {
        console.log('\n❌ Questionnaire cancelled.');
        return null;
      }
      throw error;
    }
  }

  /**
   * Ask a question with default value
   */
  async ask(question, defaultValue) {
    return new Promise((resolve, reject) => {
      const prompt = defaultValue ?
        `${question} [${defaultValue}]: ` :
        `${question}: `;

      this.rl.question(prompt, (answer) => {
        if (answer.toLowerCase() === 'ctrl+c' || answer.toLowerCase() === 'cancel') {
          reject(new Error('CANCELLED'));
          return;
        }
        resolve(answer.trim() || defaultValue);
      });
    });
  }

  /**
   * Auto-generate data for preview mode (fallback)
   */
  async autoGenerateData() {
    const packageInfo = await this.getBasicPackageInfo();
    const projectName = packageInfo.name || path.basename(this.projectPath);

    return {
      name: projectName,
      owner: 'Project Owner',
      targetUsers: 'Developers and end users',
      teamSize: 'Small team',
      purpose: packageInfo.description || 'Software project providing valuable functionality',
      problem: 'Solving common development challenges',
      features: ['Core functionality', 'User interface', 'API integration'],
      successMetrics: 'User adoption and satisfaction',
      stage: 'Development',
      milestones: 'Feature completion and testing',
      timeConstraints: 'Ongoing development',
      domain: 'Software development',
      environment: 'Web application',
      scale: 'Medium scale',
      vision: 'Create maintainable, valuable software',
      values: ['Quality', 'Maintainability', 'User focus'],
      impact: 'Positive user experience and productivity',
      architecture: 'Clean, modular architecture',
      techStack: 'Modern JavaScript/TypeScript stack',
      quality: 'High standards with automated testing',
      decisions: 'Pragmatic choices balancing quality and delivery speed'
    };
  }

  /**
   * Get basic package.json information
   */
  async getBasicPackageInfo() {
    try {
      const packagePath = path.join(this.projectPath, 'package.json');
      const packageContent = await fs.readFile(packagePath, 'utf8');
      return JSON.parse(packageContent);
    } catch {
      return {};
    }
  }

  /**
   * Count approximate words in project data
   */
  countWords(projectData) {
    const textFields = [
      projectData.owner, projectData.targetUsers, projectData.purpose,
      projectData.problem, projectData.vision, projectData.impact,
      projectData.architecture, projectData.techStack, projectData.quality,
      projectData.decisions
    ];

    const arrayFields = projectData.features.concat(projectData.values);

    const allText = textFields.concat(arrayFields).join(' ');
    return allText.split(/\s+/).filter(word => word.length > 0).length;
  }

  /**
   * Create backup of existing file
   */
  async createBackup() {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(this.projectPath, `claude-soul.md.backup.${timestamp}`);

      const existingContent = await fs.readFile(this.claudeSoulPath, 'utf8');
      await fs.writeFile(backupPath, existingContent, 'utf8');

      console.log(`📄 Backup created: ${path.basename(backupPath)}`);
    } catch (error) {
      console.warn(`⚠️ Could not create backup: ${error.message}`);
    }
  }

  /**
   * Simple confirmation prompt for overwriting existing files
   */
  async confirmOverwrite() {
    if (this.rl) {
      return new Promise((resolve) => {
        this.rl.question('⚠️ claude-soul.md exists. Overwrite? (y/N): ', (answer) => {
          resolve(answer.toLowerCase().startsWith('y'));
        });
      });
    }
    console.log('⚠️ claude-soul.md exists. Use --force to overwrite or --preview to see changes.');
    return false;
  }

  /**
   * Check if file exists
   */
  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

}

/**
 * CLI Interface for slash command
 */
export async function executeClaudeSoulCommand(args = {}) {
  const command = new ClaudeSoulSlashCommand();

  // Handle different command modes
  if (args.preview) {
    const result = await command.execute({ ...args, preview: true });
    if (result.success) {
      console.log('📄 claude-soul.md Preview:');
      console.log('━'.repeat(50));
      console.log(result.content.substring(0, 1500) + '...');
      console.log('━'.repeat(50));
      console.log(`📊 Total length: ${result.content.length} characters`);
      console.log(`📏 Lines: ${result.content.split('\n').length}`);
    }
    return result;
  }

  if (args.help) {
    console.log(`
🧠 Claude Soul - Project Context Generator

Creates a project soul document to provide AI agents with essential context
about your project's who, what, when, where, and why.

Usage:
  /claude-soul                 # Interactive questionnaire
  /claude-soul --preview       # Show preview without saving
  /claude-soul --force         # Overwrite existing file
  /claude-soul --no-interactive # Skip questionnaire, auto-generate

Purpose: When AI agents hit roadblocks, they can reference this document
to understand project goals and make decisions aligned with your vision.

Document size: 250-500 words focusing on decision-making context.
    `);
    return { success: true, action: 'help' };
  }

  // Default: run interactive questionnaire
  return await command.execute(args);
}

// For direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = {
    preview: process.argv.includes('--preview'),
    force: process.argv.includes('--force'),
    backup: !process.argv.includes('--no-backup'),
    interactive: !process.argv.includes('--no-interactive'),
    help: process.argv.includes('--help') || process.argv.includes('-h')
  };

  executeClaudeSoulCommand(args).catch(error => {
    console.error('Error:', error.message);
    process.exit(1);
  });
}