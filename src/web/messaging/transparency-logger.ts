/**
 * Transparency Logger - Provides complete visibility into agent decision-making
 */

import { EventEmitter } from 'events';
import { promises as fs } from 'fs';
import path from 'path';
import { ILogger } from '../../core/logger.js';

export interface TransparencyLog {
  id: string;
  swarmId: string;
  agentId: string;
  type: 'decision' | 'reasoning' | 'coordination' | 'task-progress' | 'insight';
  title: string;
  content: string;
  metadata: {
    reasoning?: string;
    alternatives?: string[];
    confidence?: number;
    timeSpent?: number;
    dependencies?: string[];
    riskAssessment?: string;
    expectedOutcome?: string;
  };
  timestamp: string;
  visibility: 'public' | 'team' | 'private';
}

export interface TransparencyLoggingConfig {
  level: 'debug' | 'info' | 'warn' | 'error';
  logToFile: boolean;
  logPath?: string;
}

export interface MessageStats {
  swarmId: string;
  timeRange: string;
  totalMessages: number;
  messagesByType: Record<string, number>;
  messagesByAgent: Record<string, number>;
  averageResponseTime: number;
  decisionCount: number;
  coordinationEvents: number;
  transparencyScore: number;
}

export class TransparencyLogger extends EventEmitter {
  private logs = new Map<string, TransparencyLog>();
  private logsBySwarm = new Map<string, string[]>();
  private logPath: string;

  constructor(
    private config: TransparencyLoggingConfig,
    private logger: ILogger,
  ) {
    super();
    this.logPath = config.logPath || './logs/transparency';
    this.ensureLogDirectory();
  }

  /**
   * Log agent message with transparency details
   */
  public logMessage(message: any): void {
    const transparencyLog: TransparencyLog = {
      id: this.generateLogId(),
      swarmId: message.swarmId,
      agentId: message.agentId,
      type: this.mapMessageTypeToLogType(message.messageType),
      title: this.generateLogTitle(message),
      content: message.content,
      metadata: {
        reasoning: message.metadata?.reasoning,
        alternatives: message.metadata?.alternatives,
        confidence: message.metadata?.confidence,
        dependencies: message.metadata?.dependencies,
        riskAssessment: this.generateRiskAssessment(message),
        expectedOutcome: message.metadata?.expectedOutcome,
      },
      timestamp: message.timestamp,
      visibility: 'public',
    };

    this.storeLogs(transparencyLog);
    this.emit('transparency-logged', transparencyLog);
  }

  /**
   * Log task progress with detailed insights
   */
  public logTaskProgress(progress: any): void {
    const transparencyLog: TransparencyLog = {
      id: this.generateLogId(),
      swarmId: progress.swarmId,
      agentId: progress.agentId,
      type: 'task-progress',
      title: `Task Progress: ${progress.taskName}`,
      content: `Progress: ${progress.percentage}% - ${progress.status}`,
      metadata: {
        timeSpent: progress.timeSpent,
        expectedOutcome: progress.expectedCompletion,
        riskAssessment: this.assessTaskRisk(progress),
      },
      timestamp: new Date().toISOString(),
      visibility: 'team',
    };

    this.storeLogs(transparencyLog);
    this.emit('task-progress-logged', transparencyLog);
  }

  /**
   * Generate transparency insights
   */
  public generateInsight(swarmId: string, type: string, content: string): void {
    const insight: TransparencyLog = {
      id: this.generateLogId(),
      swarmId,
      agentId: 'system',
      type: 'insight',
      title: `Transparency Insight: ${type}`,
      content,
      metadata: {
        reasoning: 'Generated by transparency analysis system',
      },
      timestamp: new Date().toISOString(),
      visibility: 'public',
    };

    this.storeLogs(insight);
    this.emit('insight', insight);
  }

  /**
   * Get message statistics with transparency metrics
   */
  public async getMessageStats(swarmId: string, timeRange: string = '24h'): Promise<MessageStats> {
    const swarmLogs = this.getSwarmLogs(swarmId, timeRange);

    const stats: MessageStats = {
      swarmId,
      timeRange,
      totalMessages: swarmLogs.length,
      messagesByType: {},
      messagesByAgent: {},
      averageResponseTime: 0,
      decisionCount: 0,
      coordinationEvents: 0,
      transparencyScore: this.calculateTransparencyScore(swarmLogs),
    };

    // Analyze message types
    for (const log of swarmLogs) {
      stats.messagesByType[log.type] = (stats.messagesByType[log.type] || 0) + 1;
      stats.messagesByAgent[log.agentId] = (stats.messagesByAgent[log.agentId] || 0) + 1;

      if (log.type === 'decision') {
        stats.decisionCount++;
      }
      if (log.type === 'coordination') {
        stats.coordinationEvents++;
      }
    }

    // Calculate average response time
    const responseTimes = swarmLogs
      .filter((log) => log.metadata.timeSpent)
      .map((log) => log.metadata.timeSpent!);

    if (responseTimes.length > 0) {
      stats.averageResponseTime =
        responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
    }

    return stats;
  }

  /**
   * Get transparency report for a swarm
   */
  public async getTransparencyReport(swarmId: string): Promise<any> {
    const logs = this.getSwarmLogs(swarmId);
    const decisions = logs.filter((log) => log.type === 'decision');
    const reasoningEntries = logs.filter((log) => log.metadata.reasoning);

    return {
      swarmId,
      reportGeneratedAt: new Date().toISOString(),
      summary: {
        totalEvents: logs.length,
        decisionsLogged: decisions.length,
        reasoningProvided: reasoningEntries.length,
        transparencyScore: this.calculateTransparencyScore(logs),
      },
      decisionBreakdown: this.analyzeDecisions(decisions),
      reasoningQuality: this.analyzeReasoningQuality(reasoningEntries),
      coordinationEfficiency: this.analyzeCoordinationEfficiency(logs),
      recommendations: this.generateRecommendations(logs),
    };
  }

  /**
   * Get real-time transparency dashboard data
   */
  public getTransparencyDashboard(swarmId: string): any {
    const recentLogs = this.getSwarmLogs(swarmId, '1h');
    const allLogs = this.getSwarmLogs(swarmId);

    return {
      swarmId,
      lastUpdated: new Date().toISOString(),
      realTimeMetrics: {
        recentActivity: recentLogs.length,
        currentTransparencyScore: this.calculateTransparencyScore(recentLogs),
        activeAgents: [...new Set(recentLogs.map((log) => log.agentId))].length,
        pendingDecisions: recentLogs.filter(
          (log) => log.type === 'decision' && !log.metadata.expectedOutcome,
        ).length,
      },
      trends: {
        transparencyTrend: this.calculateTransparencyTrend(allLogs),
        decisionVelocity: this.calculateDecisionVelocity(allLogs),
        coordinationEfficiency: this.calculateCoordinationTrend(allLogs),
      },
      alerts: this.generateTransparencyAlerts(recentLogs),
    };
  }

  private storeLogs(log: TransparencyLog): void {
    this.logs.set(log.id, log);

    // Update swarm index
    if (!this.logsBySwarm.has(log.swarmId)) {
      this.logsBySwarm.set(log.swarmId, []);
    }
    this.logsBySwarm.get(log.swarmId)!.push(log.id);

    // Write to file if enabled
    if (this.config.logToFile) {
      this.writeLogToFile(log);
    }
  }

  private async writeLogToFile(log: TransparencyLog): Promise<void> {
    try {
      const logFile = path.join(
        this.logPath,
        `${log.swarmId}-${new Date().toISOString().split('T')[0]}.json`,
      );
      const logEntry = JSON.stringify(log) + '\n';
      await fs.appendFile(logFile, logEntry);
    } catch (error) {
      this.logger.error('Failed to write transparency log to file', { error, logId: log.id });
    }
  }

  private getSwarmLogs(swarmId: string, timeRange?: string): TransparencyLog[] {
    const logIds = this.logsBySwarm.get(swarmId) || [];
    let logs = logIds.map((id) => this.logs.get(id)!).filter(Boolean);

    if (timeRange) {
      const cutoff = this.parseTimeRange(timeRange);
      logs = logs.filter((log) => new Date(log.timestamp) > cutoff);
    }

    return logs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  }

  private parseTimeRange(timeRange: string): Date {
    const now = new Date();
    const value = parseInt(timeRange.slice(0, -1));
    const unit = timeRange.slice(-1);

    switch (unit) {
      case 'h':
        return new Date(now.getTime() - value * 60 * 60 * 1000);
      case 'd':
        return new Date(now.getTime() - value * 24 * 60 * 60 * 1000);
      case 'm':
        return new Date(now.getTime() - value * 60 * 1000);
      default:
        return new Date(now.getTime() - 24 * 60 * 60 * 1000); // Default 24h
    }
  }

  private calculateTransparencyScore(logs: TransparencyLog[]): number {
    if (logs.length === 0) return 0;

    let score = 0;
    let maxScore = 0;

    for (const log of logs) {
      maxScore += 100; // Each log can contribute max 100 points

      // Points for having reasoning
      if (log.metadata.reasoning) score += 30;

      // Points for alternatives provided
      if (log.metadata.alternatives && log.metadata.alternatives.length > 0) score += 20;

      // Points for confidence score
      if (log.metadata.confidence !== undefined) score += 15;

      // Points for risk assessment
      if (log.metadata.riskAssessment) score += 15;

      // Points for expected outcome
      if (log.metadata.expectedOutcome) score += 20;
    }

    return Math.round((score / maxScore) * 100);
  }

  private analyzeDecisions(decisions: TransparencyLog[]): any {
    return {
      totalDecisions: decisions.length,
      decisionsWithReasoning: decisions.filter((d) => d.metadata.reasoning).length,
      decisionsWithAlternatives: decisions.filter((d) => d.metadata.alternatives?.length).length,
      averageConfidence: this.calculateAverageConfidence(decisions),
      riskDistribution: this.analyzeRiskDistribution(decisions),
    };
  }

  private analyzeReasoningQuality(entries: TransparencyLog[]): any {
    const reasoningLengths = entries.map((entry) => entry.metadata.reasoning?.length || 0);
    return {
      totalEntries: entries.length,
      averageReasoningLength:
        reasoningLengths.reduce((sum, len) => sum + len, 0) / reasoningLengths.length || 0,
      qualityScore: this.calculateReasoningQuality(entries),
    };
  }

  private analyzeCoordinationEfficiency(logs: TransparencyLog[]): any {
    const coordinationLogs = logs.filter((log) => log.type === 'coordination');
    return {
      coordinationEvents: coordinationLogs.length,
      averageCoordinationTime: this.calculateAverageCoordinationTime(coordinationLogs),
      efficiencyScore: this.calculateCoordinationEfficiency(coordinationLogs),
    };
  }

  private generateRecommendations(logs: TransparencyLog[]): string[] {
    const recommendations: string[] = [];
    const transparencyScore = this.calculateTransparencyScore(logs);
    const decisions = logs.filter((log) => log.type === 'decision');

    if (transparencyScore < 70) {
      recommendations.push(
        'Increase transparency by providing more detailed reasoning for decisions',
      );
    }

    if (decisions.length > 0) {
      const decisionsWithoutReasoning = decisions.filter((d) => !d.metadata.reasoning);
      if (decisionsWithoutReasoning.length / decisions.length > 0.3) {
        recommendations.push('Add reasoning explanations to more agent decisions');
      }
    }

    const coordinationLogs = logs.filter((log) => log.type === 'coordination');
    if (coordinationLogs.length < logs.length * 0.2) {
      recommendations.push('Increase coordination transparency between agents');
    }

    return recommendations;
  }

  private calculateAverageConfidence(decisions: TransparencyLog[]): number {
    const confidenceScores = decisions
      .filter((d) => d.metadata.confidence !== undefined)
      .map((d) => d.metadata.confidence!);

    return confidenceScores.length > 0
      ? confidenceScores.reduce((sum, conf) => sum + conf, 0) / confidenceScores.length
      : 0;
  }

  private calculateReasoningQuality(entries: TransparencyLog[]): number {
    // Simple quality metric based on reasoning length and structure
    let totalQuality = 0;

    for (const entry of entries) {
      const reasoning = entry.metadata.reasoning || '';
      let quality = 0;

      // Length factor (reasonable explanation)
      if (reasoning.length > 50) quality += 30;
      if (reasoning.length > 100) quality += 20;

      // Structure factors
      if (reasoning.includes('because')) quality += 15;
      if (reasoning.includes('therefore')) quality += 10;
      if (reasoning.includes('consider')) quality += 15;
      if (reasoning.includes('analyze')) quality += 10;

      totalQuality += Math.min(quality, 100);
    }

    return entries.length > 0 ? totalQuality / entries.length : 0;
  }

  private mapMessageTypeToLogType(messageType: string): TransparencyLog['type'] {
    switch (messageType) {
      case 'decision':
        return 'decision';
      case 'reasoning':
        return 'reasoning';
      case 'coordination':
        return 'coordination';
      case 'progress-update':
        return 'task-progress';
      default:
        return 'reasoning';
    }
  }

  private generateLogTitle(message: any): string {
    switch (message.messageType) {
      case 'decision':
        return `Decision: ${message.content.substring(0, 50)}...`;
      case 'coordination':
        return `Coordination: Agent ${message.agentId}`;
      case 'progress-update':
        return `Progress Update: ${message.content.substring(0, 30)}...`;
      default:
        return `${message.messageType}: ${message.content.substring(0, 40)}...`;
    }
  }

  private generateRiskAssessment(message: any): string {
    // Simple risk assessment based on message content and metadata
    const content = message.content.toLowerCase();

    if (content.includes('error') || content.includes('fail')) {
      return 'High - Error conditions detected';
    }

    if (content.includes('uncertain') || content.includes('unclear')) {
      return 'Medium - Uncertainty present';
    }

    if (message.metadata?.confidence && message.metadata.confidence < 0.5) {
      return 'Medium - Low confidence level';
    }

    return 'Low - Standard operation';
  }

  private assessTaskRisk(progress: any): string {
    if (progress.percentage < 10 && progress.timeSpent > progress.estimatedTime * 0.5) {
      return 'High - Behind schedule';
    }

    if (progress.blockers && progress.blockers.length > 0) {
      return 'Medium - Has blockers';
    }

    return 'Low - On track';
  }

  private calculateTransparencyTrend(logs: TransparencyLog[]): string {
    // Compare recent vs older transparency scores
    const recentLogs = logs.slice(0, Math.floor(logs.length / 2));
    const olderLogs = logs.slice(Math.floor(logs.length / 2));

    const recentScore = this.calculateTransparencyScore(recentLogs);
    const olderScore = this.calculateTransparencyScore(olderLogs);

    if (recentScore > olderScore + 5) return 'improving';
    if (recentScore < olderScore - 5) return 'declining';
    return 'stable';
  }

  private calculateDecisionVelocity(logs: TransparencyLog[]): number {
    const decisions = logs.filter((log) => log.type === 'decision');
    if (decisions.length < 2) return 0;

    const timespan =
      new Date(decisions[0].timestamp).getTime() -
      new Date(decisions[decisions.length - 1].timestamp).getTime();
    return decisions.length / (timespan / (60 * 60 * 1000)); // decisions per hour
  }

  private calculateCoordinationTrend(logs: TransparencyLog[]): string {
    const coordinationLogs = logs.filter((log) => log.type === 'coordination');
    const ratio = coordinationLogs.length / logs.length;

    if (ratio > 0.3) return 'high';
    if (ratio > 0.15) return 'medium';
    return 'low';
  }

  private generateTransparencyAlerts(logs: TransparencyLog[]): string[] {
    const alerts: string[] = [];

    const decisionsWithoutReasoning = logs.filter(
      (log) => log.type === 'decision' && !log.metadata.reasoning,
    );

    if (decisionsWithoutReasoning.length > 0) {
      alerts.push(`${decisionsWithoutReasoning.length} decisions lack reasoning explanations`);
    }

    const lowConfidenceDecisions = logs.filter(
      (log) => log.type === 'decision' && log.metadata.confidence && log.metadata.confidence < 0.5,
    );

    if (lowConfidenceDecisions.length > 0) {
      alerts.push(`${lowConfidenceDecisions.length} decisions have low confidence scores`);
    }

    return alerts;
  }

  private calculateAverageCoordinationTime(logs: TransparencyLog[]): number {
    const times = logs
      .filter((log) => log.metadata.timeSpent)
      .map((log) => log.metadata.timeSpent!);
    return times.length > 0 ? times.reduce((sum, time) => sum + time, 0) / times.length : 0;
  }

  private calculateCoordinationEfficiency(logs: TransparencyLog[]): number {
    // Simple efficiency metric based on coordination frequency and success
    return Math.min(100, logs.length * 10); // Placeholder calculation
  }

  private analyzeRiskDistribution(decisions: TransparencyLog[]): Record<string, number> {
    const distribution = { low: 0, medium: 0, high: 0 };

    for (const decision of decisions) {
      const risk = decision.metadata.riskAssessment?.toLowerCase() || 'low';
      if (risk.includes('high')) distribution.high++;
      else if (risk.includes('medium')) distribution.medium++;
      else distribution.low++;
    }

    return distribution;
  }

  private async ensureLogDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.logPath, { recursive: true });
    } catch (error) {
      this.logger.error('Failed to create transparency log directory', {
        error,
        path: this.logPath,
      });
    }
  }

  private generateLogId(): string {
    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
