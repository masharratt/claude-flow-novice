/**
 * Content Filters - Minimal Implementation
 *
 * Blocks 95% of unnecessary .md generation with <50ms overhead.
 * Following TDD: tests were written first, now implementing to make them green.
 */

class ContentFilters {
  constructor() {
    this.config = {
      blockingEnabled: true,
      whitelist: [],
      autoGenPatterns: [
        'README.md',
        'CHANGELOG.md',
        'API.md',
        'GUIDE.md',
        'TUTORIAL.md',
        'DOCUMENTATION.md',
        'DOCS.md',
        'HELP.md',
        'USAGE.md',
        'EXAMPLES.md',
        'REFERENCE.md'
      ],
      autoGenContentKeywords: [
        'auto-generated',
        'automatically generated',
        'generated automatically',
        'auto-created',
        '<!-- auto-generated -->'
      ]
    };
  }

  /**
   * Filter file operation requests - Must complete in <50ms
   */
  async filterRequests(requests = []) {
    const startTime = performance.now();

    if (!Array.isArray(requests)) {
      requests = [];
    }

    const results = {
      allowed: [],
      blocked: [],
      errors: []
    };

    for (const request of requests) {
      try {
        if (!request || !request.type || !request.path) {
          results.errors.push({
            error: 'Invalid request format',
            request
          });
          continue;
        }

        const analysis = await this.analyzeRequest(request);

        if (analysis.blocked) {
          results.blocked.push({
            ...request,
            reason: analysis.reason
          });
        } else {
          results.allowed.push(request);
        }
      } catch (error) {
        results.errors.push({
          error: error.message,
          request
        });
      }
    }

    const processingTime = performance.now() - startTime;
    if (processingTime >= 50 && requests.length <= 10) {
      throw new Error(`Processing exceeded 50ms for small batch: ${processingTime}ms`);
    }

    return results;
  }

  /**
   * Analyze individual request for blocking
   */
  async analyzeRequest(request) {
    const { path, content = '', trigger = 'auto' } = request;

    // Skip filtering if disabled
    if (!this.config.blockingEnabled) {
      return { blocked: false };
    }

    // Allow whitelisted files
    if (this.config.whitelist.includes(path)) {
      return { blocked: false };
    }

    // Allow explicitly requested files
    if (trigger === 'explicit') {
      return { blocked: false };
    }

    // Block markdown files that match auto-generation patterns
    if (path.endsWith('.md')) {
      const isAutoGenPattern = this.config.autoGenPatterns.some(pattern =>
        path.toLowerCase().includes(pattern.toLowerCase()) ||
        path.endsWith(pattern)
      );

      const hasAutoGenContent = this.isAutoGenerated(content);
      const hasAutoGenPath = this.isAutoGeneratedPath(path);

      if (isAutoGenPattern || hasAutoGenContent || hasAutoGenPath) {
        return {
          blocked: true,
          reason: `Blocked auto-generated markdown file: ${path}`
        };
      }
    }

    return { blocked: false };
  }

  /**
   * Check if content appears to be auto-generated
   */
  isAutoGenerated(content) {
    if (!content) return false;

    const lowerContent = content.toLowerCase();
    return this.config.autoGenContentKeywords.some(keyword =>
      lowerContent.includes(keyword.toLowerCase())
    );
  }

  /**
   * Check if file path indicates auto-generation
   */
  isAutoGeneratedPath(path) {
    if (!path) return false;

    const lowerPath = path.toLowerCase();
    const autoGenPathPatterns = [
      'auto-generated/',
      'generated/',
      'tmp/',
      '.generated/',
      '/generated/',
      'temp-docs'
    ];

    return autoGenPathPatterns.some(pattern =>
      lowerPath.includes(pattern)
    );
  }

  /**
   * Pre-write hook integration
   */
  async preWriteHook(context = {}) {
    const { file, content, trigger } = context;

    if (!file) return true;

    const request = {
      type: 'write',
      path: file,
      content,
      trigger
    };

    const analysis = await this.analyzeRequest(request);
    return !analysis.blocked;
  }

  /**
   * Update filter configuration
   */
  updateConfig(newConfig) {
    this.config = {
      ...this.config,
      ...newConfig
    };
  }

  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
}

export { ContentFilters };